package gldapo

import java.io.File

import javax.naming.Context
import javax.naming.InitialContext
import javax.naming.NamingException
import javax.naming.directory.Attribute
import javax.naming.directory.Attributes
import javax.naming.directory.BasicAttribute
import javax.naming.directory.BasicAttributes
import javax.naming.directory.DirContext

import com.novell.ldap.LDAPConnection
import com.novell.ldap.util.LDIFWriter
import com.novell.ldap.LDAPException

import org.apache.directory.server.core.configuration.MutablePartitionConfiguration
import org.apache.directory.server.unit.AbstractServerTest

abstract public class AbstractGldapoIntegrationTest extends AbstractServerTest
{
    def gldapo
    def partitionName = "gldapo"
    def partitionSuffix = "o=$partitionName"
    def jldapConnection

     public void setUp() {
         def pcfg = new MutablePartitionConfiguration()
         pcfg.name = partitionName
         pcfg.suffix = partitionSuffix
         pcfg.indexedAttributes = ["objectClass", "o"] as Set

         def attrs = new BasicAttributes(true)
         def attr = new BasicAttribute("objectClass")
         attr.add("top")
         attr.add("organization")
         attrs.put(attr)

         attr = new BasicAttribute("o")
         attr.add(partitionName)
         attrs.put(attr)
         pcfg.contextEntry = attrs

         def pcfgs = new HashSet<MutablePartitionConfiguration>()
         pcfgs.add(pcfg)

         configuration.contextPartitionConfigurations = pcfgs
         configuration.workingDirectory = new File("target/ldap-server")

         super.setUp()

         initGldapo()
         initJldapConnection()
    }

    def initGldapo() {
        gldapo = new Gldapo(
            directories: [
                local: [
                    url: "ldap://localhost:${configuration.ldapPort}",
                    base: partitionSuffix,
                    userDn: "uid=admin,ou=system",
                    password: "secret"
                ]
            ],
            schemas: getSchemaClasses(),
            typeMappings: getTypeMappings()
        )
    }

    def getSchemaClasses() {
        []
    }

    def getTypeMappings() {
        []
    }

    void importEntry(name, ldif) {
        importEntry(name, null, ldif)
    }

    void importEntry(name, parent, ldif) {
        assertEquals("Argument 1 to importEntry() must be a one element Map", 1, name.size())
        def entry = name.find { true }
        def namingAttr = entry.key
        def namingValue = entry.value

        def cleanedLdif = new StringBuffer()
        cleanedLdif << ((parent) ? "dn: $namingAttr=$namingValue,$parent,$partitionSuffix\n" : "dn: $namingAttr=$namingValue,$partitionSuffix\n")
        cleanedLdif << "$namingAttr: $namingValue\n"

        ldif.eachLine { line ->
            line = line.trim()
            cleanedLdif << line + "\n"
        }

        def ldifStream = new ByteArrayInputStream(cleanedLdif.toString().bytes)
        importLdif(ldifStream)
    }

    void initJldapConnection() {
        jldapConnection = new LDAPConnection()
        jldapConnection.connect("localhost", configuration.ldapPort)
        jldapConnection.bind(3, "uid=admin,ou=system", "secret" as byte[])
    }

    def getEntry(dn) {
        try {
            return jldapConnection.read("$dn,$partitionSuffix")
        } catch (LDAPException e) {
            if (e.resultCode == LDAPException.NO_SUCH_OBJECT)
                return null
            else
                throw e
        }
    }

    void assertEqualsLdif(dn, expectedLdif) {

        def entry = getEntry(dn)
        assertNotNull("$dn is not an entry", entry)

        def output = new ByteArrayOutputStream()
        def writer = new LDIFWriter(output)
        writer.writeEntry(entry)
        writer.finish()

        def actualLdif = output.toString() - "# This LDIF file was generated by the LDIF APIs. of Novell's Java LDAP SDK\nversion: 1\n\ndn: $dn,$partitionSuffix\n"
        def cleanedExpectedLdifBuffer = new StringBuffer()

        expectedLdif.eachLine { line ->
            line = line.trim()
            if (line.size() > 0) cleanedExpectedLdifBuffer << line + "\n"
        }

        assertEquals(
            "$dn did not match expected ldif",
            cleanedExpectedLdifBuffer.toString().readLines().sort().join("\n"),
            actualLdif.readLines().collect { it.trim() }.findAll { it.size() > 0 }.sort().join("\n")
        )
    }

    public void tearDown() {
        super.tearDown()
    }
    
    protected String shouldFail(Closure code) {
        boolean failed = false;
        String result = null;
        try {
            code.call();
        }
        catch (GroovyRuntimeException gre) {
            failed = true;
            result = ScriptBytecodeAdapter.unwrap(gre).getMessage();
        }
        catch (Throwable e) {
                failed = true;
                result = e.getMessage();
        }
        assertTrue("Closure " + code + " should have failed", failed);
        return result;
    }

    protected String shouldFail(Class clazz, Closure code) {
        Throwable th = null;
        try {
            code.call();
        } catch (GroovyRuntimeException gre) {
            th = ScriptBytecodeAdapter.unwrap(gre);
        } catch (Throwable e) {
            th = e;
        }

        if (th==null) {
            fail("Closure " + code + " should have failed with an exception of type " + clazz.getName());
        } else if (! clazz.isInstance(th)) {
            fail("Closure " + code + " should have failed with an exception of type " + clazz.getName() + ", instead got Exception " + th);
        }
        return th.getMessage();
    }

    protected String shouldFailWithCause(Class clazz, Closure code) {
        Throwable th = null;
        try {
            code.call();
        } catch (GroovyRuntimeException gre) {
            th = gre;
            while (th.getCause()!=null && th.getCause()!=gre){ // if wrapped, find the root cause
                th=th.getCause();
                if (th!=gre && (th instanceof GroovyRuntimeException)) {
                    gre = (GroovyRuntimeException) th;
                }
            }
        } catch (Throwable e) {
            th = e;
        }

        if (th==null) {
            fail("Closure " + code + " should have failed with an exception of type " + clazz.getName());
        } else if (! clazz.isInstance(th)) {
            fail("Closure " + code + " should have failed with an exception of type " + clazz.getName() + ", instead got Exception " + th);
        }
        return th.getMessage();
    }
    
}